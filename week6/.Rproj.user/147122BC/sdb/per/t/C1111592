{
    "contents" : "library(igraph)\nlibrary(graph)\n\n# Graph File Format:\n# 0 -> 3\n# 1 -> 0\n# 2 -> 1,6\n# 3 -> 2\n# 4 -> 2\n# 5 -> 4\n# 6 -> 5,8\n# 7 -> 9\n# 8 -> 7\n# 9 -> 6\n  \ngraphFromFile_v0 <- function(inputFile){\n  inputs <- readLines(con=inputFile, warn=F)\n  splittedInputs <- strsplit(inputs, \"\\\\s->\\\\s\")\n  elems <- unlist(splittedInputs)\n  len <- length(elems)\n  from <- elems[seq(from=1, to=len, by=2)]\n  to <- elems[seq(from=2, to=len, by=2)]\n  edL <- strsplit(to, \",\")\n  #edL <- lapply(edL, function(l){return(as.numeric(l))}) ## convert to numeric edge list\n  names(edL) <- from\n  gR <- graphNEL(nodes=from, edgeL=edL, edgemode=\"directed\")\n  return(gR)\n}\n\ngraphFromFile <- function(inputFile){\n  inputs <- readLines(con=inputFile, warn=F)\n  splittedInputs <- strsplit(inputs, \"\\\\s->\\\\s\")\n  elems <- unlist(splittedInputs)\n  len <- length(elems)\n  from <- elems[seq(from=1, to=len, by=2)]\n  to <- elems[seq(from=2, to=len, by=2)]\n  edL <- strsplit(to, \",\")\n  names(edL) <- from\n  \n  ## add non existing nodes and correspoding empty edge\n  noEdgeNodes <- setdiff(unique(unlist(edL)), from)\n  from <- c(from, noEdgeNodes)\n  lapply(noEdgeNodes, function(n){edL[[n]] <<- new(\"character\")})\n  \n  gR <- graphNEL(nodes=from, edgeL=edL, edgemode=\"directed\")\n  return(gR)\n}\n\n# Format: \n# 0->1:7\n# 0->2:4\n# 2->3:2\n# 1->4:1\n# 3->4:3  \n\n#each edge is a string\n\nweightedGraphFromEdges <- function(edges, sep.dir=\"->\", sep.w=\":\"){\n  splittedInputs <- strsplit(edges, split=paste0(sep.dir,\"|\",sep.w))\n  elems <- unlist(splittedInputs)\n  len <- length(elems)\n  from <- elems[seq(from=1, to=len, by=3)]\n  to <- elems[seq(from=2, to=len, by=3)]\n  w <- as.numeric(elems[seq(from=3, to=len, by=3)])\n  w <- max(w) - w\n  \n  nodes <- unique(append(from, to))\n  g <- graphNEL(nodes=nodes, edgemode=\"directed\")\n  g <- addEdge(from=from, to=to, weights=w, graph=g)\n  return(g)\n}\n\neulerCycle <- function(g, start=NULL){\n  eulerCycle <- c()\n  curNode <- ifelse(is.null(start), nodes(g)[1], start)\n  \n  \n  while(!is.na(curNode)){\n    cycle <- curNode\n    \n    while(!is.na(nextNode <- randomWalkNext(g, curNode))){\n      g <- removeEdge(graph=g, from=curNode, to=nextNode)\n      cycle <- append(cycle, nextNode)\n      curNode <- nextNode\n    }\n    \n    if(length(eulerCycle)==0){\n      eulerCycle <- cycle\n    }\n    else{\n      insertIndex <- which(eulerCycle==cycle[1])[1]\n      eulerCycle <- append(eulerCycle,after=insertIndex,values=cycle[-1])\n    }\n    \n    curNode <- getAnUnexploredNode(g, nodes=eulerCycle)\n  }\n  \n  return(eulerCycle)\n  \n}\n\ngetAnUnexploredNode <- function(g, nodes){\n  degrees <- degree(g, Nodes=nodes)\n  nodeIndexes <- which(degrees$outDegree+degrees$inDegree>0)\n  node <- NA\n  if(length(nodeIndexes)>0){\n    node <- nodes[nodeIndexes[1]]\n  }\n  return(node)\n}\n\ngetUnexploredNodes <- function(g, nodes){\n  degrees <- degree(g, Nodes=nodes)\n  nodeIndexes <- which(degrees$outDegree>0)\n  return(nodes[nodeIndexes])\n}\n\nrandomWalkNext <- function(g, from){\n  outEdges <- edges(object=g, which=from)[[1]]\n  nextNode <- NA\n  if(length(outEdges)>0){\n    nextNode <- outEdges[1]\n  }\n  return(nextNode)\n}\n\n\neulerian <- function(g, start=NULL){\n  eulerPath <- c()\n  \n  curNode <- ifelse(is.null(start), selectAStartNodeForEulerian(g), start)\n  \n  unexplored <- character()\n  count <- 0\n  \n  ed <- edges(g)\n  startIndex <- 1\n  endIndex <- length(ed)\n  \n  while(!is.na(curNode)){\n    cycle <- curNode\n    \n    while(TRUE){\n      \n      # !is.na(nextNode <- randomWalkNext(g, curNode))\n      moves <- ed[[curNode]]\n      nextNode <- ifelse(length(moves)>0, moves[1], NA)\n      if(is.na(nextNode))\n        break;\n      \n      #g <- removeEdge(graph=g, from=curNode, to=nextNode)\n      ed[[curNode]] <- ed[[curNode]][-1]\n      \n      \n      cycle <- append(cycle, nextNode)\n      curNode <- nextNode\n      \n      count <- count + 1\n      if(count%%1000==0){\n        print(count)\n      }\n      \n      \n    }\n    \n    if(length(eulerPath)==0){\n      eulerPath <- cycle\n    }\n    else{\n      insertIndex <- which(eulerPath==cycle[1])[1]\n      eulerPath <- append(eulerPath,after=insertIndex,values=cycle[-1])\n    }\n    \n    \n    #t1 <- Sys.time()\n    curNode <- NA\n    while((startIndex <- startIndex + 1) <= endIndex){\n      node <- eulerPath[startIndex]\n      # if has unexplored edge\n      if(length(ed[[node]])>0){\n        curNode <- node\n        break\n      }\n    }\n    \n    #print(curNode)\n    \n    #t2 <- Sys.time()\n    #print(t2 - t1)\n    \n#     t1 <- Sys.time()\n#     \n#     hasEdge <- sapply(eulerPath, function(n){\n#       return(length(ed[[n]])>0)\n#     })\n#     \n#     indexes <- which(hasEdge)\n#     curNode <- ifelse(length(indexes)>0, eulerPath[indexes[1]], NA)\n#     \n#     t2 <- Sys.time()\n#     print(t2 - t1)\n    \n    count <- count + 1\n    #     if(count%%1000==0){\n    #       print(count)\n    #     }\n  }\n  \n  #print(count)\n  return(eulerPath)\n  \n}\n\n\neulerian_v2 <- function(g, start=NULL){\n  eulerPath <- c()\n  \n  curNode <- ifelse(is.null(start), selectAStartNodeForEulerian(g), start)\n  count <- 0\n  \n  ed <- edges(g)\n  \n  while(!is.na(curNode)){\n    cycle <- curNode\n    \n    while(TRUE){\n      \n      # !is.na(nextNode <- randomWalkNext(g, curNode))\n      moves <- ed[[curNode]]\n      nextNode <- ifelse(length(moves)>0, moves[1], NA)\n      if(is.na(nextNode))\n        break;\n      \n      #g <- removeEdge(graph=g, from=curNode, to=nextNode)\n      ed[[curNode]] <- ed[[curNode]][-1]\n      \n      \n      cycle <- append(cycle, nextNode)\n      curNode <- nextNode\n      \n#       count <- count + 1\n#       if(count%%1000==0){\n#         print(count)\n#         #gc()\n#       }\n        \n        \n    }\n    \n    if(length(eulerPath)==0){\n      eulerPath <- cycle\n    }\n    else{\n      insertIndex <- which(eulerPath==cycle[1])[1]\n      eulerPath <- append(eulerPath,after=insertIndex,values=cycle[-1])\n    }\n    \n    #unexplored <- getUnexploredNodes(g, nodes=unique(append(unexplored, cycle)))\n    #curNode <- ifelse(length(unexplored)==0, NA, unexplored[1])\n    \n    #g <- graphNEL(nodes=nodes(g), edgeL=ed, edgemode=\"directed\")\n    #curNode <- getAnUnexploredNode(g, nodes=eulerPath)\n\n    t1 <- Sys.time()\n\n    hasEdge <- sapply(eulerPath, function(n){\n      return(length(ed[[n]])>0)\n    })\n\n    indexes <- which(hasEdge)\n    curNode <- ifelse(length(indexes)>0, eulerPath[indexes[1]], NA)\n\n    t2 <- Sys.time()\n    print(t2 - t1)\n\n    count <- count + 1\n#     if(count%%1000==0){\n#       print(count)\n#     }\n  }\n  \n  print(count)\n  return(eulerPath)\n  \n}\n\n\neulerian_v1 <- function(g, start=NULL){\n  eulerPath <- c()\n  \n  curNode <- ifelse(is.null(start), selectAStartNodeForEulerian(g), start)\n  \n  \n  while(!is.na(curNode)){\n    cycle <- curNode\n    \n    while(!is.na(nextNode <- randomWalkNext(g, curNode))){\n      g <- removeEdge(graph=g, from=curNode, to=nextNode)\n      cycle <- append(cycle, nextNode)\n      curNode <- nextNode\n    }\n    \n    if(length(eulerPath)==0){\n      eulerPath <- cycle\n    }\n    else{\n      insertIndex <- which(eulerPath==cycle[1])[1]\n      eulerPath <- append(eulerPath,after=insertIndex,values=cycle[-1])\n    }\n    \n    curNode <- getAnUnexploredNode(g, nodes=eulerPath)\n  }\n  \n  return(eulerPath)\n  \n}\n\n\nselectAStartNodeForEulerian <- function(g){\n  nodes <- nodes(g)\n  deg <- degree(g, Nodes=nodes)\n  degDiff <- deg$outDegree - deg$inDegree\n  degDiff1Index <- which(degDiff==1)\n  if(length(degDiff1Index)==1){\n    startNode <- nodes[degDiff1Index]\n  }else if(length(degDiff1Index)==0){\n    startNode <- nodes[1]\n  }else{\n    stop(\"There is no eulerian path in this graph.\")\n  }\n  \n  return(startNode)\n}\n\n\n# getDeBrujinEdges <- function(patterns){\n#   k <- length(patterns[1])\n#   from <- substr(patterns, 1, k-1)\n#   to <- substr(patterns, 2, k)\n#     \n#   substr(c(\"abc\",\"def\"),1,2)\n#   \n#   edges <- lapply(patterns, function(p){return(character())})\n#   names(edges) <- patterns\n#   \n#   createDeBrujinEdge <- function(pattern){\n#     len <- str_length(pattern)\n#     prefix <- substr(pattern,start=1,stop=len-1)\n#     suffix <- substr(pattern,start=2,stop=len)\n#     return(c(from=prefix, to=suffix))\n#   }\n#   \n#   allEdges <- sapply(patterns, createDeBrujinEdge)\n#   allEdges <- t(allEdges)\n#   collapsedEdges <- aggregate(to~from, allEdges, paste0, sep=\"\", collapse=\",\")\n#   return(collapsedEdges)\n# }\n\n\n# g must be graphNEL\ngetLongestPathInDAG <- function(g, from, to){\n  ig <- igraph.from.graphNEL(g)\n  inodes <- V(ig)\n  nodeIndex <- topological.sort(ig)\n  shortestPath <- get.shortest.paths(graph=ig, from=which(inodes==from), to=which(inodes==to))\n  print(shortestPath)\n  \n}",
    "created" : 1396867222038.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "4207663400",
    "id" : "C1111592",
    "lastKnownWriteTime" : 1393147175,
    "path" : "D:/Copy/Coursera/Bioinformatics Algorithms (part-I)/MyPrograms/week6/code/utility.graph.R",
    "project_path" : "code/utility.graph.R",
    "properties" : {
    },
    "source_on_save" : false,
    "type" : "r_source"
}